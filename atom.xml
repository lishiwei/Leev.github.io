<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lishiwei&#39;Notes</title>
  <subtitle>所想,所感,所悟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-05-13T12:44:42.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lishiwei:(Leev)</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java 内存模型和垃圾回收机制</title>
    <link href="http://yoursite.com/2016/05/13/2016-5-13/"/>
    <id>http://yoursite.com/2016/05/13/2016-5-13/</id>
    <published>2016-05-13T11:03:02.000Z</published>
    <updated>2016-05-13T12:44:42.000Z</updated>
    
    <content type="html">&lt;h1 id=&quot;java内存模型&quot;&gt;&lt;a href=&quot;#java内存模型&quot; class=&quot;headerlink&quot; title=&quot;java内存模型&quot;&gt;&lt;/a&gt;java内存模型&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;  最近两天关注了java和Android的内存模型和垃圾回收机制，先整理如下。本篇文章是从很多篇文章中摘抄的，会在后面有个统一的转载地址的。&lt;/p&gt;
&lt;p&gt;大家都知道Android应用层是由java开发的，Android的dalvik虚拟机与jvm类似，不过他是基于寄存器的，速度会更快。因此在了解Android的内存管理机制之前需要先了解下java的内存分配和垃圾回收机制。&lt;br&gt;在java中通过new 关键字来为对象分配内存，而内存是由GC来回收的。因此java工程师就不用去手动管理内存了。但是这样有可能在不知不觉中就会浪费了很多内存，最终导致java虚拟机花费很多时间去进行垃圾回收，更严重的是造成JVM的OOM。因此，java工程师有必要去了解java的内存分配和垃圾回收机制。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存结构图&lt;br&gt;&lt;img src=&quot;http://hi.csdn.net/attachment/201108/22/0_13139780444m7y.gif&quot; alt=&quot;java 内存结构图&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面这张图是JVM的结构图，它主要四个部分组成：Class Loader子系统和执行引擎，运行时方法区和本地方法区，我们主要来看下RUNTIME DATA AREA区，也就是我们常说的JVM内存。从图中可以看出，RUNTIMEDATA AREA区主要由5个部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Method Area:被装载的class的元信息存储在Method Area中，它是线程共享的&lt;/li&gt;
&lt;li&gt;Heap(堆)：一个java虚拟机实例中只存在一个堆空间，存放一些对象信 息，它是线程共享的&lt;/li&gt;
&lt;li&gt;Java栈： java虚拟机直接对java栈进行两种操作，以帧为单位的压栈和出栈（非线程共享）&lt;/li&gt;
&lt;li&gt;程序计数器（非线程共享）&lt;/li&gt;
&lt;li&gt;本地方法栈（非线程共享）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上文章摘抄自&lt;a href=&quot;http://blog.csdn.net/xieqibao/article/details/6707519&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;csdn 舍我其谁的专栏&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;接下来我们重点关注下-Heap-区&quot;&gt;&lt;a href=&quot;#接下来我们重点关注下-Heap-区&quot; class=&quot;headerlink&quot; title=&quot;接下来我们重点关注下 Heap 区&quot;&gt;&lt;/a&gt;接下来我们重点关注下 &lt;strong&gt;Heap&lt;/strong&gt; 区&lt;/h4&gt;&lt;p&gt;　　Java 中的堆是 JVM 所管理的最大的一块内存空间，主要用于存放各种类的实例对象。 &lt;/p&gt;
&lt;p&gt;  在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。 &lt;/p&gt;
&lt;p&gt;  这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。&lt;br&gt;　　堆的内存模型大致为：&lt;br&gt;  &lt;br&gt;   &lt;img src=&quot;http://img.blog.csdn.net/20160229115517775&quot; alt=&quot;&quot;&gt;&lt;br&gt;  &lt;br&gt;　　新生代：Young Generation，主要用来存放新生的对象。&lt;/p&gt;
&lt;p&gt;　　老年代：Old Generation或者称作Tenured Generation，主要存放应用程序声明周期长的内存对象。&lt;/p&gt;
&lt;p&gt;　　永久代：（方法区，不属于java堆，另一个别名为“非堆Non-Heap”但是一般查看PrintGCDetails都会带上PermGen区）是指内存的永久保存区域，主要存放Class和Meta的信息,Class在被 Load的时候被放入PermGen space区域. 它和和存放Instance的Heap区域不同,GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的应用会加载很多Class的话,就很可能出现PermGen space错误。&lt;/p&gt;
&lt;p&gt;　　堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。&lt;/p&gt;
&lt;p&gt;　　默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。&lt;/p&gt;
&lt;p&gt;　　默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。&lt;br&gt;JVM 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。&lt;br&gt;因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。&lt;/p&gt;
&lt;h1 id=&quot;Gc&quot;&gt;&lt;a href=&quot;#Gc&quot; class=&quot;headerlink&quot; title=&quot;Gc&quot;&gt;&lt;/a&gt;Gc&lt;/h1&gt;&lt;p&gt;常见的垃圾回收算法有引用计数法（Reference Counting）、标注并清理（Mark and Sweep GC）、拷贝（Copying GC）和逐代回收（Generational GC）等算法，&lt;br&gt;关于这四种GC算法，详解请看此篇&lt;a href=&quot;http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;java内存垃圾回收算法&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下文中 Minor GC 代表拷贝（Copying GC）算法 。Full GC 或者 Major GC代表 标记并清理算法（Mark and Sweep GC）&lt;/p&gt;
&lt;p&gt;新生代几乎是所有 Java 对象出生的地方，即 Java 对象申请的内存以及存放都是在这个地方。Java 中的大部分对象通常不需长久存活，具有朝生夕灭的性质。&lt;/p&gt;
&lt;p&gt;当一个对象被判定为 “死亡” 的时候，GC 就有责任来回收掉这部分对象的内存空间。新生代是 GC 收集垃圾的频繁区域。&lt;/p&gt;
&lt;p&gt;当对象在 Eden ( 包括一个 Survivor 区域，这里假设是 from 区域 ) 出生后，在经过一次 Minor GC 后，如果对象还存活，并且能够被另外一块 Survivor 区域所容纳( 上面已经假设为 from 区域，这里应为 to 区域，即 to 区域有足够的内存空间来存储 Eden 和 from 区域中存活的对象 )，则使用复制算法将这些仍然还存活的对象复制到另外一块 Survivor 区域 ( 即 to 区域 ) 中，然后清理所使用过的 Eden 以及 Survivor 区域 ( 即 from 区域 )，并且将这些对象的年龄设置为1，以后对象在 Survivor 区每熬过一次 Minor GC，就将对象的年龄 + 1，当对象的年龄达到某个值时 ( 默认是 15 岁，可以通过参数 -XX:MaxTenuringThreshold 来设定 )，这些对象就会成为老年代。&lt;/p&gt;
&lt;p&gt;但这也不是一定的，对于一些较大的对象 ( 即需要分配一块较大的连续内存空间 ) 则是直接进入到老年代。虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。&lt;/p&gt;
&lt;p&gt;为了能够更好的适应不同的程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无需等到MaxTenuringThreshold中要求的年龄。 &lt;/p&gt;
&lt;p&gt;Full GC 是发生在老年代的垃圾收集动作，所采用的是“标记-清除”或者“标记-整理”算法。 &lt;/p&gt;
&lt;p&gt;现实的生活中，老年代的人通常会比新生代的人 “早死”。堆内存中的老年代(Old)不同于这个，老年代里面的对象几乎个个都是在 Survivor 区域中熬过来的，它们是不会那么容易就 “死掉” 了的。因此，Full GC 发生的次数不会有 Minor GC 那么频繁，并且做一次 Full GC 要比进行一次 Minor GC 的时间更长。&lt;/p&gt;
&lt;p&gt;在发生MinorGC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么MinorGC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试这进行一次MinorGC，尽管这次MinorGC是有风险的；如果小于，或者HandlePromptionFailure设置不允许冒险，那这是也要改为进行一次FullGC. &lt;/p&gt;
&lt;p&gt;另外，标记-清除算法收集垃圾的时候会产生许多的内存碎片 ( 即不连续的内存空间 )，此后需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次 GC 的收集动作。&lt;br&gt;以上文章摘抄自 csdn 朱小厮的文章 &lt;a href=&quot;http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文中文章的链接：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;csdn 舍我其谁的文章 &lt;a href=&quot;http://blog.csdn.net/xieqibao/article/details/6707519&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/xieqibao/article/details/6707519&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;博客园 killmyday的文章 &lt;a href=&quot;http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;csdn 朱小厮的文章 &lt;a href=&quot;http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.cnblogs.com/killmyday/archive/2013/06/12/3132518.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;java内存模型&quot;&gt;&lt;a href=&quot;#java内存模型&quot; class=&quot;headerlink&quot; title=&quot;java内存模型&quot;&gt;&lt;/a&gt;java内存模型&lt;/h1&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="java内存模型垃圾回收" scheme="http://yoursite.com/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android中static关键字的生命周期问题</title>
    <link href="http://yoursite.com/2016/05/02/2016-5-2-9-14/"/>
    <id>http://yoursite.com/2016/05/02/2016-5-2-9-14/</id>
    <published>2016-05-02T13:22:17.000Z</published>
    <updated>2016-05-02T15:16:05.000Z</updated>
    
    <content type="html">&lt;p&gt;#android中static关键字的生命周期问题&lt;/p&gt;
&lt;p&gt;  年前有次心血来潮跑去毫无准备的跑去平安面试。面试官看我的代码里面有很多static变量，便问我Android中的static生命周期的问题，当时理解是错误的，以为Activity或者Fragment里面的static变量的生命周期跟自己的生命周期相同。在这里说明一下，static是存储于dalvik虚拟机的方法区的，类加载的时候static变量加载进方法区，当整个应用进程被kill掉，static变量才会被置null。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;由此&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在activity中不能用static变量去引用自己，除非在生命周期ondestroy里面显示置null，不然会造成activity泄露。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;不能在Application里面存储static变量，如果你的应用是后台进程，并且内存不足的时候Android会kill掉此应用，Application里面的static变量也会置null，此后内存不紧张的时候回尝试重启Application，但是Application里面的static变量已为null。当你从任务栈或者桌面图标里再次进入这个Application，并且使用static变量的时候就会发生空指针异常了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;#android中static关键字的生命周期问题&lt;/p&gt;
&lt;p&gt;  年前有次心血来潮跑去毫无准备的跑去平安面试。面试官看我的代码里面有很多static变量，便问我Android中的static生命周期的问题，当时理解是错误的，以为Activity或者Fragment里面的
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="static" scheme="http://yoursite.com/tags/static/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2016/05/01/postname/"/>
    <id>http://yoursite.com/2016/05/01/postname/</id>
    <published>2016-05-01T11:11:23.000Z</published>
    <updated>2016-05-02T15:07:01.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;—&quot;&gt;&lt;a href=&quot;#—&quot; class=&quot;headerlink&quot; title=&quot;—&quot;&gt;&lt;/a&gt;—&lt;/h2&gt;&lt;p&gt;#创建于2016年5月1日。&lt;/p&gt;
&lt;p&gt;耗费三个小时创建了本博客&lt;/p&gt;
&lt;p&gt;以后会多多发文章的。欢迎多多拍砖。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;—&quot;&gt;&lt;a href=&quot;#—&quot; class=&quot;headerlink&quot; title=&quot;—&quot;&gt;&lt;/a&gt;—&lt;/h2&gt;&lt;p&gt;#创建于2016年5月1日。&lt;/p&gt;
&lt;p&gt;耗费三个小时创建了本博客&lt;/p&gt;
&lt;p&gt;以后会多多发文章的。欢迎多多拍砖。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2016/05/01/hello-world/"/>
    <id>http://yoursite.com/2016/05/01/hello-world/</id>
    <published>2016-05-01T10:37:59.000Z</published>
    <updated>2016-05-02T15:08:42.000Z</updated>
    
    <content type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/generating.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Generating&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Deploy-to-remote-sites&quot;&gt;&lt;a href=&quot;#Deploy-to-remote-sites&quot; class=&quot;headerlink&quot; title=&quot;Deploy to remote sites&quot;&gt;&lt;/a&gt;Deploy to remote sites&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo deploy&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/deployment.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Deployment&lt;/a&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
  </entry>
  
</feed>
